
/**
 * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
 *
 * Do not edit this file as changes may cause incorrect behavior and will be lost
 * once the code is regenerated.
 *
 * @generated by codegen project: GeneratePropsH.js
 */
#pragma once

#include <cinttypes>
#include <folly/dynamic.h>
#include <react/renderer/components/view/ViewProps.h>
#include <react/renderer/core/PropsParserContext.h>
#include <react/renderer/core/propsConversions.h>
#include <react/renderer/graphics/Color.h>
#include <vector>

namespace facebook {
namespace react {

enum class RNJWPlayerCategory { Ambient, SoloAmbient, Playback, Record, PlayAndRecord, MultiRoute };

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNJWPlayerCategory &result) {
  auto string = (std::string)value;
  if (string == "Ambient") { result = RNJWPlayerCategory::Ambient; return; }
  if (string == "SoloAmbient") { result = RNJWPlayerCategory::SoloAmbient; return; }
  if (string == "Playback") { result = RNJWPlayerCategory::Playback; return; }
  if (string == "Record") { result = RNJWPlayerCategory::Record; return; }
  if (string == "PlayAndRecord") { result = RNJWPlayerCategory::PlayAndRecord; return; }
  if (string == "MultiRoute") { result = RNJWPlayerCategory::MultiRoute; return; }
  abort();
}

static inline std::string toString(const RNJWPlayerCategory &value) {
  switch (value) {
    case RNJWPlayerCategory::Ambient: return "Ambient";
    case RNJWPlayerCategory::SoloAmbient: return "SoloAmbient";
    case RNJWPlayerCategory::Playback: return "Playback";
    case RNJWPlayerCategory::Record: return "Record";
    case RNJWPlayerCategory::PlayAndRecord: return "PlayAndRecord";
    case RNJWPlayerCategory::MultiRoute: return "MultiRoute";
  }
}

enum class RNJWPlayerMode { Default, VoiceChat, VideoChat, GameChat, VideoRecording, Measurement, MoviePlayback, SpokenAudio, VoicePrompt };

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNJWPlayerMode &result) {
  auto string = (std::string)value;
  if (string == "Default") { result = RNJWPlayerMode::Default; return; }
  if (string == "VoiceChat") { result = RNJWPlayerMode::VoiceChat; return; }
  if (string == "VideoChat") { result = RNJWPlayerMode::VideoChat; return; }
  if (string == "GameChat") { result = RNJWPlayerMode::GameChat; return; }
  if (string == "VideoRecording") { result = RNJWPlayerMode::VideoRecording; return; }
  if (string == "Measurement") { result = RNJWPlayerMode::Measurement; return; }
  if (string == "MoviePlayback") { result = RNJWPlayerMode::MoviePlayback; return; }
  if (string == "SpokenAudio") { result = RNJWPlayerMode::SpokenAudio; return; }
  if (string == "VoicePrompt") { result = RNJWPlayerMode::VoicePrompt; return; }
  abort();
}

static inline std::string toString(const RNJWPlayerMode &value) {
  switch (value) {
    case RNJWPlayerMode::Default: return "Default";
    case RNJWPlayerMode::VoiceChat: return "VoiceChat";
    case RNJWPlayerMode::VideoChat: return "VideoChat";
    case RNJWPlayerMode::GameChat: return "GameChat";
    case RNJWPlayerMode::VideoRecording: return "VideoRecording";
    case RNJWPlayerMode::Measurement: return "Measurement";
    case RNJWPlayerMode::MoviePlayback: return "MoviePlayback";
    case RNJWPlayerMode::SpokenAudio: return "SpokenAudio";
    case RNJWPlayerMode::VoicePrompt: return "VoicePrompt";
  }
}

enum class RNJWPlayerPreload { Auto, None };

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNJWPlayerPreload &result) {
  auto string = (std::string)value;
  if (string == "auto") { result = RNJWPlayerPreload::Auto; return; }
  if (string == "none") { result = RNJWPlayerPreload::None; return; }
  abort();
}

static inline std::string toString(const RNJWPlayerPreload &value) {
  switch (value) {
    case RNJWPlayerPreload::Auto: return "auto";
    case RNJWPlayerPreload::None: return "none";
  }
}

enum class RNJWPlayerInterfaceBehavior { Normal, Hidden, Onscreen };

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNJWPlayerInterfaceBehavior &result) {
  auto string = (std::string)value;
  if (string == "normal") { result = RNJWPlayerInterfaceBehavior::Normal; return; }
  if (string == "hidden") { result = RNJWPlayerInterfaceBehavior::Hidden; return; }
  if (string == "onscreen") { result = RNJWPlayerInterfaceBehavior::Onscreen; return; }
  abort();
}

static inline std::string toString(const RNJWPlayerInterfaceBehavior &value) {
  switch (value) {
    case RNJWPlayerInterfaceBehavior::Normal: return "normal";
    case RNJWPlayerInterfaceBehavior::Hidden: return "hidden";
    case RNJWPlayerInterfaceBehavior::Onscreen: return "onscreen";
  }
}

enum class RNJWPlayerCategoryOptions { MixWithOthers, DuckOthers, AllowBluetooth, DefaultToSpeaker, InterruptSpokenAudioAndMix, AllowBluetoothA2DP, AllowAirPlay, OverrideMutedMicrophone };

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNJWPlayerCategoryOptions &result) {
  auto string = (std::string)value;
  if (string == "MixWithOthers") { result = RNJWPlayerCategoryOptions::MixWithOthers; return; }
  if (string == "DuckOthers") { result = RNJWPlayerCategoryOptions::DuckOthers; return; }
  if (string == "AllowBluetooth") { result = RNJWPlayerCategoryOptions::AllowBluetooth; return; }
  if (string == "DefaultToSpeaker") { result = RNJWPlayerCategoryOptions::DefaultToSpeaker; return; }
  if (string == "InterruptSpokenAudioAndMix") { result = RNJWPlayerCategoryOptions::InterruptSpokenAudioAndMix; return; }
  if (string == "AllowBluetoothA2DP") { result = RNJWPlayerCategoryOptions::AllowBluetoothA2DP; return; }
  if (string == "AllowAirPlay") { result = RNJWPlayerCategoryOptions::AllowAirPlay; return; }
  if (string == "OverrideMutedMicrophone") { result = RNJWPlayerCategoryOptions::OverrideMutedMicrophone; return; }
  abort();
}

static inline std::string toString(const RNJWPlayerCategoryOptions &value) {
  switch (value) {
    case RNJWPlayerCategoryOptions::MixWithOthers: return "MixWithOthers";
    case RNJWPlayerCategoryOptions::DuckOthers: return "DuckOthers";
    case RNJWPlayerCategoryOptions::AllowBluetooth: return "AllowBluetooth";
    case RNJWPlayerCategoryOptions::DefaultToSpeaker: return "DefaultToSpeaker";
    case RNJWPlayerCategoryOptions::InterruptSpokenAudioAndMix: return "InterruptSpokenAudioAndMix";
    case RNJWPlayerCategoryOptions::AllowBluetoothA2DP: return "AllowBluetoothA2DP";
    case RNJWPlayerCategoryOptions::AllowAirPlay: return "AllowAirPlay";
    case RNJWPlayerCategoryOptions::OverrideMutedMicrophone: return "OverrideMutedMicrophone";
  }
}

enum class RNJWPlayerHideUIGroups { overlay, control_bar, center_controls, next_up, error, playlist, controls_container, settings_menu, quality_submenu, captions_submenu, playback_submenu, audiotracks_submenu, casting_menu, };

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNJWPlayerHideUIGroups &result) {
  auto string = (std::string)value;
  if (string == "overlay") { result = RNJWPlayerHideUIGroups::overlay; return; }
  if (string == "control_bar") { result = RNJWPlayerHideUIGroups::control_bar; return; }
  if (string == "center_controls") { result = RNJWPlayerHideUIGroups::center_controls; return; }
  if (string == "next_up") { result = RNJWPlayerHideUIGroups::next_up; return; }
  if (string == "error") { result = RNJWPlayerHideUIGroups::error; return; }
  if (string == "playlist") { result = RNJWPlayerHideUIGroups::playlist; return; }
  if (string == "controls_container") { result = RNJWPlayerHideUIGroups::controls_container; return; }
  if (string == "settings_menu") { result = RNJWPlayerHideUIGroups::settings_menu; return; }
  if (string == "quality_submenu") { result = RNJWPlayerHideUIGroups::quality_submenu; return; }
  if (string == "captions_submenu") { result = RNJWPlayerHideUIGroups::captions_submenu; return; }
  if (string == "playback_submenu") { result = RNJWPlayerHideUIGroups::playback_submenu; return; }
  if (string == "audiotracks_submenu") { result = RNJWPlayerHideUIGroups::audiotracks_submenu; return; }
  if (string == "casting_menu") { result = RNJWPlayerHideUIGroups::casting_menu; return; }
  abort();
}

static inline std::string toString(const RNJWPlayerHideUIGroups &value) {
  switch (value) {
    case RNJWPlayerHideUIGroups::overlay: return "overlay";
    case RNJWPlayerHideUIGroups::control_bar: return "control_bar";
    case RNJWPlayerHideUIGroups::center_controls: return "center_controls";
    case RNJWPlayerHideUIGroups::next_up: return "next_up";
    case RNJWPlayerHideUIGroups::error: return "error";
    case RNJWPlayerHideUIGroups::playlist: return "playlist";
    case RNJWPlayerHideUIGroups::controls_container: return "controls_container";
    case RNJWPlayerHideUIGroups::settings_menu: return "settings_menu";
    case RNJWPlayerHideUIGroups::quality_submenu: return "quality_submenu";
    case RNJWPlayerHideUIGroups::captions_submenu: return "captions_submenu";
    case RNJWPlayerHideUIGroups::playback_submenu: return "playback_submenu";
    case RNJWPlayerHideUIGroups::audiotracks_submenu: return "audiotracks_submenu";
    case RNJWPlayerHideUIGroups::casting_menu: return "casting_menu";
  }
}

struct RNJWPlayerConfigVastAdvertisingAdScheduleStruct {
  std::string tag;
  std::string offset;
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNJWPlayerConfigVastAdvertisingAdScheduleStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_tag = map.find("tag");
  if (tmp_tag != map.end()) {
    fromRawValue(context, tmp_tag->second, result.tag);
  }
  auto tmp_offset = map.find("offset");
  if (tmp_offset != map.end()) {
    fromRawValue(context, tmp_offset->second, result.offset);
  }
}

static inline std::string toString(const RNJWPlayerConfigVastAdvertisingAdScheduleStruct &value) {
  return "[Object RNJWPlayerConfigVastAdvertisingAdScheduleStruct]";
}

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, std::vector<RNJWPlayerConfigVastAdvertisingAdScheduleStruct> &result) {
  auto items = (std::vector<RawValue>)value;
  for (const auto &item : items) {
    RNJWPlayerConfigVastAdvertisingAdScheduleStruct newItem;
    fromRawValue(context, item, newItem);
    result.emplace_back(newItem);
  }
}


struct RNJWPlayerConfigVastAdvertisingAdRulesStruct {
  Float startOn;
  Float frequency;
  Float timeBetweenAds;
  std::string startOnSeek;
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNJWPlayerConfigVastAdvertisingAdRulesStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_startOn = map.find("startOn");
  if (tmp_startOn != map.end()) {
    fromRawValue(context, tmp_startOn->second, result.startOn);
  }
  auto tmp_frequency = map.find("frequency");
  if (tmp_frequency != map.end()) {
    fromRawValue(context, tmp_frequency->second, result.frequency);
  }
  auto tmp_timeBetweenAds = map.find("timeBetweenAds");
  if (tmp_timeBetweenAds != map.end()) {
    fromRawValue(context, tmp_timeBetweenAds->second, result.timeBetweenAds);
  }
  auto tmp_startOnSeek = map.find("startOnSeek");
  if (tmp_startOnSeek != map.end()) {
    fromRawValue(context, tmp_startOnSeek->second, result.startOnSeek);
  }
}

static inline std::string toString(const RNJWPlayerConfigVastAdvertisingAdRulesStruct &value) {
  return "[Object RNJWPlayerConfigVastAdvertisingAdRulesStruct]";
}

struct RNJWPlayerConfigVastAdvertisingAdSettingsStruct {
  bool allowsBackgroundPlayback;
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNJWPlayerConfigVastAdvertisingAdSettingsStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_allowsBackgroundPlayback = map.find("allowsBackgroundPlayback");
  if (tmp_allowsBackgroundPlayback != map.end()) {
    fromRawValue(context, tmp_allowsBackgroundPlayback->second, result.allowsBackgroundPlayback);
  }
}

static inline std::string toString(const RNJWPlayerConfigVastAdvertisingAdSettingsStruct &value) {
  return "[Object RNJWPlayerConfigVastAdvertisingAdSettingsStruct]";
}

struct RNJWPlayerConfigVastAdvertisingStruct {
  std::vector<RNJWPlayerConfigVastAdvertisingAdScheduleStruct> adSchedule;
  std::string adVmap;
  std::string tag;
  bool openBrowserOnAdClick;
  std::string adClient;
  RNJWPlayerConfigVastAdvertisingAdRulesStruct adRules;
  RNJWPlayerConfigVastAdvertisingAdSettingsStruct adSettings;
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNJWPlayerConfigVastAdvertisingStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_adSchedule = map.find("adSchedule");
  if (tmp_adSchedule != map.end()) {
    fromRawValue(context, tmp_adSchedule->second, result.adSchedule);
  }
  auto tmp_adVmap = map.find("adVmap");
  if (tmp_adVmap != map.end()) {
    fromRawValue(context, tmp_adVmap->second, result.adVmap);
  }
  auto tmp_tag = map.find("tag");
  if (tmp_tag != map.end()) {
    fromRawValue(context, tmp_tag->second, result.tag);
  }
  auto tmp_openBrowserOnAdClick = map.find("openBrowserOnAdClick");
  if (tmp_openBrowserOnAdClick != map.end()) {
    fromRawValue(context, tmp_openBrowserOnAdClick->second, result.openBrowserOnAdClick);
  }
  auto tmp_adClient = map.find("adClient");
  if (tmp_adClient != map.end()) {
    fromRawValue(context, tmp_adClient->second, result.adClient);
  }
  auto tmp_adRules = map.find("adRules");
  if (tmp_adRules != map.end()) {
    fromRawValue(context, tmp_adRules->second, result.adRules);
  }
  auto tmp_adSettings = map.find("adSettings");
  if (tmp_adSettings != map.end()) {
    fromRawValue(context, tmp_adSettings->second, result.adSettings);
  }
}

static inline std::string toString(const RNJWPlayerConfigVastAdvertisingStruct &value) {
  return "[Object RNJWPlayerConfigVastAdvertisingStruct]";
}

struct RNJWPlayerConfigImaAdvertisingAdScheduleStruct {
  std::string tag;
  std::string offset;
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNJWPlayerConfigImaAdvertisingAdScheduleStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_tag = map.find("tag");
  if (tmp_tag != map.end()) {
    fromRawValue(context, tmp_tag->second, result.tag);
  }
  auto tmp_offset = map.find("offset");
  if (tmp_offset != map.end()) {
    fromRawValue(context, tmp_offset->second, result.offset);
  }
}

static inline std::string toString(const RNJWPlayerConfigImaAdvertisingAdScheduleStruct &value) {
  return "[Object RNJWPlayerConfigImaAdvertisingAdScheduleStruct]";
}

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, std::vector<RNJWPlayerConfigImaAdvertisingAdScheduleStruct> &result) {
  auto items = (std::vector<RawValue>)value;
  for (const auto &item : items) {
    RNJWPlayerConfigImaAdvertisingAdScheduleStruct newItem;
    fromRawValue(context, item, newItem);
    result.emplace_back(newItem);
  }
}


struct RNJWPlayerConfigImaAdvertisingAdRulesStruct {
  Float startOn;
  Float frequency;
  Float timeBetweenAds;
  std::string startOnSeek;
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNJWPlayerConfigImaAdvertisingAdRulesStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_startOn = map.find("startOn");
  if (tmp_startOn != map.end()) {
    fromRawValue(context, tmp_startOn->second, result.startOn);
  }
  auto tmp_frequency = map.find("frequency");
  if (tmp_frequency != map.end()) {
    fromRawValue(context, tmp_frequency->second, result.frequency);
  }
  auto tmp_timeBetweenAds = map.find("timeBetweenAds");
  if (tmp_timeBetweenAds != map.end()) {
    fromRawValue(context, tmp_timeBetweenAds->second, result.timeBetweenAds);
  }
  auto tmp_startOnSeek = map.find("startOnSeek");
  if (tmp_startOnSeek != map.end()) {
    fromRawValue(context, tmp_startOnSeek->second, result.startOnSeek);
  }
}

static inline std::string toString(const RNJWPlayerConfigImaAdvertisingAdRulesStruct &value) {
  return "[Object RNJWPlayerConfigImaAdvertisingAdRulesStruct]";
}

struct RNJWPlayerConfigImaAdvertisingImaSettingsStruct {
  std::string locale;
  std::string ppid;
  int maxRedirects;
  std::string sessionID;
  bool debugMode;
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNJWPlayerConfigImaAdvertisingImaSettingsStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_locale = map.find("locale");
  if (tmp_locale != map.end()) {
    fromRawValue(context, tmp_locale->second, result.locale);
  }
  auto tmp_ppid = map.find("ppid");
  if (tmp_ppid != map.end()) {
    fromRawValue(context, tmp_ppid->second, result.ppid);
  }
  auto tmp_maxRedirects = map.find("maxRedirects");
  if (tmp_maxRedirects != map.end()) {
    fromRawValue(context, tmp_maxRedirects->second, result.maxRedirects);
  }
  auto tmp_sessionID = map.find("sessionID");
  if (tmp_sessionID != map.end()) {
    fromRawValue(context, tmp_sessionID->second, result.sessionID);
  }
  auto tmp_debugMode = map.find("debugMode");
  if (tmp_debugMode != map.end()) {
    fromRawValue(context, tmp_debugMode->second, result.debugMode);
  }
}

static inline std::string toString(const RNJWPlayerConfigImaAdvertisingImaSettingsStruct &value) {
  return "[Object RNJWPlayerConfigImaAdvertisingImaSettingsStruct]";
}

struct RNJWPlayerConfigImaAdvertisingStruct {
  std::vector<RNJWPlayerConfigImaAdvertisingAdScheduleStruct> adSchedule;
  std::string adVmap;
  std::string tag;
  std::string adClient;
  RNJWPlayerConfigImaAdvertisingAdRulesStruct adRules;
  RNJWPlayerConfigImaAdvertisingImaSettingsStruct imaSettings;
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNJWPlayerConfigImaAdvertisingStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_adSchedule = map.find("adSchedule");
  if (tmp_adSchedule != map.end()) {
    fromRawValue(context, tmp_adSchedule->second, result.adSchedule);
  }
  auto tmp_adVmap = map.find("adVmap");
  if (tmp_adVmap != map.end()) {
    fromRawValue(context, tmp_adVmap->second, result.adVmap);
  }
  auto tmp_tag = map.find("tag");
  if (tmp_tag != map.end()) {
    fromRawValue(context, tmp_tag->second, result.tag);
  }
  auto tmp_adClient = map.find("adClient");
  if (tmp_adClient != map.end()) {
    fromRawValue(context, tmp_adClient->second, result.adClient);
  }
  auto tmp_adRules = map.find("adRules");
  if (tmp_adRules != map.end()) {
    fromRawValue(context, tmp_adRules->second, result.adRules);
  }
  auto tmp_imaSettings = map.find("imaSettings");
  if (tmp_imaSettings != map.end()) {
    fromRawValue(context, tmp_imaSettings->second, result.imaSettings);
  }
}

static inline std::string toString(const RNJWPlayerConfigImaAdvertisingStruct &value) {
  return "[Object RNJWPlayerConfigImaAdvertisingStruct]";
}

struct RNJWPlayerConfigDaiAdvertisingImaSettingsStruct {
  std::string locale;
  std::string ppid;
  int maxRedirects;
  std::string sessionID;
  bool debugMode;
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNJWPlayerConfigDaiAdvertisingImaSettingsStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_locale = map.find("locale");
  if (tmp_locale != map.end()) {
    fromRawValue(context, tmp_locale->second, result.locale);
  }
  auto tmp_ppid = map.find("ppid");
  if (tmp_ppid != map.end()) {
    fromRawValue(context, tmp_ppid->second, result.ppid);
  }
  auto tmp_maxRedirects = map.find("maxRedirects");
  if (tmp_maxRedirects != map.end()) {
    fromRawValue(context, tmp_maxRedirects->second, result.maxRedirects);
  }
  auto tmp_sessionID = map.find("sessionID");
  if (tmp_sessionID != map.end()) {
    fromRawValue(context, tmp_sessionID->second, result.sessionID);
  }
  auto tmp_debugMode = map.find("debugMode");
  if (tmp_debugMode != map.end()) {
    fromRawValue(context, tmp_debugMode->second, result.debugMode);
  }
}

static inline std::string toString(const RNJWPlayerConfigDaiAdvertisingImaSettingsStruct &value) {
  return "[Object RNJWPlayerConfigDaiAdvertisingImaSettingsStruct]";
}

struct RNJWPlayerConfigDaiAdvertisingGoogleDAIStreamStruct {
  std::string videoID;
  std::string cmsID;
  std::string assetKey;
  std::string apiKey;
  folly::dynamic adTagParameters;
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNJWPlayerConfigDaiAdvertisingGoogleDAIStreamStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_videoID = map.find("videoID");
  if (tmp_videoID != map.end()) {
    fromRawValue(context, tmp_videoID->second, result.videoID);
  }
  auto tmp_cmsID = map.find("cmsID");
  if (tmp_cmsID != map.end()) {
    fromRawValue(context, tmp_cmsID->second, result.cmsID);
  }
  auto tmp_assetKey = map.find("assetKey");
  if (tmp_assetKey != map.end()) {
    fromRawValue(context, tmp_assetKey->second, result.assetKey);
  }
  auto tmp_apiKey = map.find("apiKey");
  if (tmp_apiKey != map.end()) {
    fromRawValue(context, tmp_apiKey->second, result.apiKey);
  }
  auto tmp_adTagParameters = map.find("adTagParameters");
  if (tmp_adTagParameters != map.end()) {
    fromRawValue(context, tmp_adTagParameters->second, result.adTagParameters);
  }
}

static inline std::string toString(const RNJWPlayerConfigDaiAdvertisingGoogleDAIStreamStruct &value) {
  return "[Object RNJWPlayerConfigDaiAdvertisingGoogleDAIStreamStruct]";
}

struct RNJWPlayerConfigDaiAdvertisingStruct {
  std::string adClient;
  RNJWPlayerConfigDaiAdvertisingImaSettingsStruct imaSettings;
  RNJWPlayerConfigDaiAdvertisingGoogleDAIStreamStruct googleDAIStream;
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNJWPlayerConfigDaiAdvertisingStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_adClient = map.find("adClient");
  if (tmp_adClient != map.end()) {
    fromRawValue(context, tmp_adClient->second, result.adClient);
  }
  auto tmp_imaSettings = map.find("imaSettings");
  if (tmp_imaSettings != map.end()) {
    fromRawValue(context, tmp_imaSettings->second, result.imaSettings);
  }
  auto tmp_googleDAIStream = map.find("googleDAIStream");
  if (tmp_googleDAIStream != map.end()) {
    fromRawValue(context, tmp_googleDAIStream->second, result.googleDAIStream);
  }
}

static inline std::string toString(const RNJWPlayerConfigDaiAdvertisingStruct &value) {
  return "[Object RNJWPlayerConfigDaiAdvertisingStruct]";
}

struct RNJWPlayerConfigNextUpStyleStruct {
  Float offsetSeconds;
  Float offsetPercentage;
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNJWPlayerConfigNextUpStyleStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_offsetSeconds = map.find("offsetSeconds");
  if (tmp_offsetSeconds != map.end()) {
    fromRawValue(context, tmp_offsetSeconds->second, result.offsetSeconds);
  }
  auto tmp_offsetPercentage = map.find("offsetPercentage");
  if (tmp_offsetPercentage != map.end()) {
    fromRawValue(context, tmp_offsetPercentage->second, result.offsetPercentage);
  }
}

static inline std::string toString(const RNJWPlayerConfigNextUpStyleStruct &value) {
  return "[Object RNJWPlayerConfigNextUpStyleStruct]";
}

struct RNJWPlayerConfigStylingColorsTimesliderStruct {
  SharedColor progress;
  SharedColor rail;
  SharedColor thumb;
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNJWPlayerConfigStylingColorsTimesliderStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_progress = map.find("progress");
  if (tmp_progress != map.end()) {
    fromRawValue(context, tmp_progress->second, result.progress);
  }
  auto tmp_rail = map.find("rail");
  if (tmp_rail != map.end()) {
    fromRawValue(context, tmp_rail->second, result.rail);
  }
  auto tmp_thumb = map.find("thumb");
  if (tmp_thumb != map.end()) {
    fromRawValue(context, tmp_thumb->second, result.thumb);
  }
}

static inline std::string toString(const RNJWPlayerConfigStylingColorsTimesliderStruct &value) {
  return "[Object RNJWPlayerConfigStylingColorsTimesliderStruct]";
}

struct RNJWPlayerConfigStylingColorsStruct {
  SharedColor buttons;
  SharedColor backgroundColor;
  SharedColor fontColor;
  RNJWPlayerConfigStylingColorsTimesliderStruct timeslider;
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNJWPlayerConfigStylingColorsStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_buttons = map.find("buttons");
  if (tmp_buttons != map.end()) {
    fromRawValue(context, tmp_buttons->second, result.buttons);
  }
  auto tmp_backgroundColor = map.find("backgroundColor");
  if (tmp_backgroundColor != map.end()) {
    fromRawValue(context, tmp_backgroundColor->second, result.backgroundColor);
  }
  auto tmp_fontColor = map.find("fontColor");
  if (tmp_fontColor != map.end()) {
    fromRawValue(context, tmp_fontColor->second, result.fontColor);
  }
  auto tmp_timeslider = map.find("timeslider");
  if (tmp_timeslider != map.end()) {
    fromRawValue(context, tmp_timeslider->second, result.timeslider);
  }
}

static inline std::string toString(const RNJWPlayerConfigStylingColorsStruct &value) {
  return "[Object RNJWPlayerConfigStylingColorsStruct]";
}

struct RNJWPlayerConfigStylingFontStruct {
  std::string name;
  Float size;
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNJWPlayerConfigStylingFontStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_name = map.find("name");
  if (tmp_name != map.end()) {
    fromRawValue(context, tmp_name->second, result.name);
  }
  auto tmp_size = map.find("size");
  if (tmp_size != map.end()) {
    fromRawValue(context, tmp_size->second, result.size);
  }
}

static inline std::string toString(const RNJWPlayerConfigStylingFontStruct &value) {
  return "[Object RNJWPlayerConfigStylingFontStruct]";
}

struct RNJWPlayerConfigStylingCaptionsStyleFontStruct {
  std::string name;
  Float size;
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNJWPlayerConfigStylingCaptionsStyleFontStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_name = map.find("name");
  if (tmp_name != map.end()) {
    fromRawValue(context, tmp_name->second, result.name);
  }
  auto tmp_size = map.find("size");
  if (tmp_size != map.end()) {
    fromRawValue(context, tmp_size->second, result.size);
  }
}

static inline std::string toString(const RNJWPlayerConfigStylingCaptionsStyleFontStruct &value) {
  return "[Object RNJWPlayerConfigStylingCaptionsStyleFontStruct]";
}

struct RNJWPlayerConfigStylingCaptionsStyleStruct {
  RNJWPlayerConfigStylingCaptionsStyleFontStruct font;
  SharedColor fontColor;
  SharedColor backgroundColor;
  SharedColor highlightColor;
  std::string edgeStyle;
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNJWPlayerConfigStylingCaptionsStyleStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_font = map.find("font");
  if (tmp_font != map.end()) {
    fromRawValue(context, tmp_font->second, result.font);
  }
  auto tmp_fontColor = map.find("fontColor");
  if (tmp_fontColor != map.end()) {
    fromRawValue(context, tmp_fontColor->second, result.fontColor);
  }
  auto tmp_backgroundColor = map.find("backgroundColor");
  if (tmp_backgroundColor != map.end()) {
    fromRawValue(context, tmp_backgroundColor->second, result.backgroundColor);
  }
  auto tmp_highlightColor = map.find("highlightColor");
  if (tmp_highlightColor != map.end()) {
    fromRawValue(context, tmp_highlightColor->second, result.highlightColor);
  }
  auto tmp_edgeStyle = map.find("edgeStyle");
  if (tmp_edgeStyle != map.end()) {
    fromRawValue(context, tmp_edgeStyle->second, result.edgeStyle);
  }
}

static inline std::string toString(const RNJWPlayerConfigStylingCaptionsStyleStruct &value) {
  return "[Object RNJWPlayerConfigStylingCaptionsStyleStruct]";
}

struct RNJWPlayerConfigStylingMenuStyleFontStruct {
  std::string name;
  Float size;
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNJWPlayerConfigStylingMenuStyleFontStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_name = map.find("name");
  if (tmp_name != map.end()) {
    fromRawValue(context, tmp_name->second, result.name);
  }
  auto tmp_size = map.find("size");
  if (tmp_size != map.end()) {
    fromRawValue(context, tmp_size->second, result.size);
  }
}

static inline std::string toString(const RNJWPlayerConfigStylingMenuStyleFontStruct &value) {
  return "[Object RNJWPlayerConfigStylingMenuStyleFontStruct]";
}

struct RNJWPlayerConfigStylingMenuStyleStruct {
  RNJWPlayerConfigStylingMenuStyleFontStruct font;
  SharedColor fontColor;
  SharedColor backgroundColor;
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNJWPlayerConfigStylingMenuStyleStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_font = map.find("font");
  if (tmp_font != map.end()) {
    fromRawValue(context, tmp_font->second, result.font);
  }
  auto tmp_fontColor = map.find("fontColor");
  if (tmp_fontColor != map.end()) {
    fromRawValue(context, tmp_fontColor->second, result.fontColor);
  }
  auto tmp_backgroundColor = map.find("backgroundColor");
  if (tmp_backgroundColor != map.end()) {
    fromRawValue(context, tmp_backgroundColor->second, result.backgroundColor);
  }
}

static inline std::string toString(const RNJWPlayerConfigStylingMenuStyleStruct &value) {
  return "[Object RNJWPlayerConfigStylingMenuStyleStruct]";
}

struct RNJWPlayerConfigStylingStruct {
  RNJWPlayerConfigStylingColorsStruct colors;
  RNJWPlayerConfigStylingFontStruct font;
  bool displayTitle;
  bool displayDescription;
  RNJWPlayerConfigStylingCaptionsStyleStruct captionsStyle;
  RNJWPlayerConfigStylingMenuStyleStruct menuStyle;
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNJWPlayerConfigStylingStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_colors = map.find("colors");
  if (tmp_colors != map.end()) {
    fromRawValue(context, tmp_colors->second, result.colors);
  }
  auto tmp_font = map.find("font");
  if (tmp_font != map.end()) {
    fromRawValue(context, tmp_font->second, result.font);
  }
  auto tmp_displayTitle = map.find("displayTitle");
  if (tmp_displayTitle != map.end()) {
    fromRawValue(context, tmp_displayTitle->second, result.displayTitle);
  }
  auto tmp_displayDescription = map.find("displayDescription");
  if (tmp_displayDescription != map.end()) {
    fromRawValue(context, tmp_displayDescription->second, result.displayDescription);
  }
  auto tmp_captionsStyle = map.find("captionsStyle");
  if (tmp_captionsStyle != map.end()) {
    fromRawValue(context, tmp_captionsStyle->second, result.captionsStyle);
  }
  auto tmp_menuStyle = map.find("menuStyle");
  if (tmp_menuStyle != map.end()) {
    fromRawValue(context, tmp_menuStyle->second, result.menuStyle);
  }
}

static inline std::string toString(const RNJWPlayerConfigStylingStruct &value) {
  return "[Object RNJWPlayerConfigStylingStruct]";
}

struct RNJWPlayerConfigPlaylistSourcesStruct {
  std::string file;
  std::string label;
  bool isDefault;
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNJWPlayerConfigPlaylistSourcesStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_file = map.find("file");
  if (tmp_file != map.end()) {
    fromRawValue(context, tmp_file->second, result.file);
  }
  auto tmp_label = map.find("label");
  if (tmp_label != map.end()) {
    fromRawValue(context, tmp_label->second, result.label);
  }
  auto tmp_isDefault = map.find("isDefault");
  if (tmp_isDefault != map.end()) {
    fromRawValue(context, tmp_isDefault->second, result.isDefault);
  }
}

static inline std::string toString(const RNJWPlayerConfigPlaylistSourcesStruct &value) {
  return "[Object RNJWPlayerConfigPlaylistSourcesStruct]";
}

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, std::vector<RNJWPlayerConfigPlaylistSourcesStruct> &result) {
  auto items = (std::vector<RawValue>)value;
  for (const auto &item : items) {
    RNJWPlayerConfigPlaylistSourcesStruct newItem;
    fromRawValue(context, item, newItem);
    result.emplace_back(newItem);
  }
}


struct RNJWPlayerConfigPlaylistAdScheduleStruct {
  std::string tag;
  std::string offset;
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNJWPlayerConfigPlaylistAdScheduleStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_tag = map.find("tag");
  if (tmp_tag != map.end()) {
    fromRawValue(context, tmp_tag->second, result.tag);
  }
  auto tmp_offset = map.find("offset");
  if (tmp_offset != map.end()) {
    fromRawValue(context, tmp_offset->second, result.offset);
  }
}

static inline std::string toString(const RNJWPlayerConfigPlaylistAdScheduleStruct &value) {
  return "[Object RNJWPlayerConfigPlaylistAdScheduleStruct]";
}

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, std::vector<RNJWPlayerConfigPlaylistAdScheduleStruct> &result) {
  auto items = (std::vector<RawValue>)value;
  for (const auto &item : items) {
    RNJWPlayerConfigPlaylistAdScheduleStruct newItem;
    fromRawValue(context, item, newItem);
    result.emplace_back(newItem);
  }
}


struct RNJWPlayerConfigPlaylistTracksStruct {
  std::string file;
  std::string label;
  bool isDefault;
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNJWPlayerConfigPlaylistTracksStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_file = map.find("file");
  if (tmp_file != map.end()) {
    fromRawValue(context, tmp_file->second, result.file);
  }
  auto tmp_label = map.find("label");
  if (tmp_label != map.end()) {
    fromRawValue(context, tmp_label->second, result.label);
  }
  auto tmp_isDefault = map.find("isDefault");
  if (tmp_isDefault != map.end()) {
    fromRawValue(context, tmp_isDefault->second, result.isDefault);
  }
}

static inline std::string toString(const RNJWPlayerConfigPlaylistTracksStruct &value) {
  return "[Object RNJWPlayerConfigPlaylistTracksStruct]";
}

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, std::vector<RNJWPlayerConfigPlaylistTracksStruct> &result) {
  auto items = (std::vector<RawValue>)value;
  for (const auto &item : items) {
    RNJWPlayerConfigPlaylistTracksStruct newItem;
    fromRawValue(context, item, newItem);
    result.emplace_back(newItem);
  }
}


struct RNJWPlayerConfigPlaylistStruct {
  std::string file;
  std::vector<RNJWPlayerConfigPlaylistSourcesStruct> sources;
  std::string image;
  std::string title;
  std::string description;
  std::string mediaId;
  std::vector<RNJWPlayerConfigPlaylistAdScheduleStruct> adSchedule;
  std::string adVmap;
  std::vector<RNJWPlayerConfigPlaylistTracksStruct> tracks;
  std::string recommendations;
  Float startTime;
  bool autostart;
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNJWPlayerConfigPlaylistStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_file = map.find("file");
  if (tmp_file != map.end()) {
    fromRawValue(context, tmp_file->second, result.file);
  }
  auto tmp_sources = map.find("sources");
  if (tmp_sources != map.end()) {
    fromRawValue(context, tmp_sources->second, result.sources);
  }
  auto tmp_image = map.find("image");
  if (tmp_image != map.end()) {
    fromRawValue(context, tmp_image->second, result.image);
  }
  auto tmp_title = map.find("title");
  if (tmp_title != map.end()) {
    fromRawValue(context, tmp_title->second, result.title);
  }
  auto tmp_description = map.find("description");
  if (tmp_description != map.end()) {
    fromRawValue(context, tmp_description->second, result.description);
  }
  auto tmp_mediaId = map.find("mediaId");
  if (tmp_mediaId != map.end()) {
    fromRawValue(context, tmp_mediaId->second, result.mediaId);
  }
  auto tmp_adSchedule = map.find("adSchedule");
  if (tmp_adSchedule != map.end()) {
    fromRawValue(context, tmp_adSchedule->second, result.adSchedule);
  }
  auto tmp_adVmap = map.find("adVmap");
  if (tmp_adVmap != map.end()) {
    fromRawValue(context, tmp_adVmap->second, result.adVmap);
  }
  auto tmp_tracks = map.find("tracks");
  if (tmp_tracks != map.end()) {
    fromRawValue(context, tmp_tracks->second, result.tracks);
  }
  auto tmp_recommendations = map.find("recommendations");
  if (tmp_recommendations != map.end()) {
    fromRawValue(context, tmp_recommendations->second, result.recommendations);
  }
  auto tmp_startTime = map.find("startTime");
  if (tmp_startTime != map.end()) {
    fromRawValue(context, tmp_startTime->second, result.startTime);
  }
  auto tmp_autostart = map.find("autostart");
  if (tmp_autostart != map.end()) {
    fromRawValue(context, tmp_autostart->second, result.autostart);
  }
}

static inline std::string toString(const RNJWPlayerConfigPlaylistStruct &value) {
  return "[Object RNJWPlayerConfigPlaylistStruct]";
}

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, std::vector<RNJWPlayerConfigPlaylistStruct> &result) {
  auto items = (std::vector<RawValue>)value;
  for (const auto &item : items) {
    RNJWPlayerConfigPlaylistStruct newItem;
    fromRawValue(context, item, newItem);
    result.emplace_back(newItem);
  }
}


struct RNJWPlayerConfigRelatedStruct {
  std::string onClick;
  std::string onComplete;
  std::string heading;
  std::string url;
  std::string autoplayMessage;
  Float autoplayTimer;
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNJWPlayerConfigRelatedStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_onClick = map.find("onClick");
  if (tmp_onClick != map.end()) {
    fromRawValue(context, tmp_onClick->second, result.onClick);
  }
  auto tmp_onComplete = map.find("onComplete");
  if (tmp_onComplete != map.end()) {
    fromRawValue(context, tmp_onComplete->second, result.onComplete);
  }
  auto tmp_heading = map.find("heading");
  if (tmp_heading != map.end()) {
    fromRawValue(context, tmp_heading->second, result.heading);
  }
  auto tmp_url = map.find("url");
  if (tmp_url != map.end()) {
    fromRawValue(context, tmp_url->second, result.url);
  }
  auto tmp_autoplayMessage = map.find("autoplayMessage");
  if (tmp_autoplayMessage != map.end()) {
    fromRawValue(context, tmp_autoplayMessage->second, result.autoplayMessage);
  }
  auto tmp_autoplayTimer = map.find("autoplayTimer");
  if (tmp_autoplayTimer != map.end()) {
    fromRawValue(context, tmp_autoplayTimer->second, result.autoplayTimer);
  }
}

static inline std::string toString(const RNJWPlayerConfigRelatedStruct &value) {
  return "[Object RNJWPlayerConfigRelatedStruct]";
}

struct RNJWPlayerConfigStruct {
  std::string license;
  RNJWPlayerConfigVastAdvertisingStruct vastAdvertising;
  RNJWPlayerConfigImaAdvertisingStruct imaAdvertising;
  RNJWPlayerConfigDaiAdvertisingStruct daiAdvertising;
  bool autostart;
  bool controls;
  bool repeat;
  RNJWPlayerConfigNextUpStyleStruct nextUpStyle;
  RNJWPlayerConfigStylingStruct styling;
  bool backgroundAudioEnabled;
  RNJWPlayerCategory category;
  RNJWPlayerCategoryOptions categoryOptions;
  RNJWPlayerMode mode;
  bool fullScreenOnLandscape;
  bool landscapeOnFullScreen;
  bool portraitOnExitFullScreen;
  bool exitFullScreenOnPortrait;
  std::vector<RNJWPlayerConfigPlaylistStruct> playlist;
  std::string stretching;
  RNJWPlayerConfigRelatedStruct related;
  RNJWPlayerPreload preload;
  RNJWPlayerInterfaceBehavior interfaceBehavior;
  Float interfaceFadeDelay;
  RNJWPlayerHideUIGroups hideUIGroups;
  std::string processSpcUrl;
  std::string fairplayCertUrl;
  std::string contentUUID;
  bool viewOnly;
  bool enableLockScreenControls;
  bool pipEnabled;
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNJWPlayerConfigStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_license = map.find("license");
  if (tmp_license != map.end()) {
    fromRawValue(context, tmp_license->second, result.license);
  }
  auto tmp_vastAdvertising = map.find("vastAdvertising");
  if (tmp_vastAdvertising != map.end()) {
    fromRawValue(context, tmp_vastAdvertising->second, result.vastAdvertising);
  }
  auto tmp_imaAdvertising = map.find("imaAdvertising");
  if (tmp_imaAdvertising != map.end()) {
    fromRawValue(context, tmp_imaAdvertising->second, result.imaAdvertising);
  }
  auto tmp_daiAdvertising = map.find("daiAdvertising");
  if (tmp_daiAdvertising != map.end()) {
    fromRawValue(context, tmp_daiAdvertising->second, result.daiAdvertising);
  }
  auto tmp_autostart = map.find("autostart");
  if (tmp_autostart != map.end()) {
    fromRawValue(context, tmp_autostart->second, result.autostart);
  }
  auto tmp_controls = map.find("controls");
  if (tmp_controls != map.end()) {
    fromRawValue(context, tmp_controls->second, result.controls);
  }
  auto tmp_repeat = map.find("repeat");
  if (tmp_repeat != map.end()) {
    fromRawValue(context, tmp_repeat->second, result.repeat);
  }
  auto tmp_nextUpStyle = map.find("nextUpStyle");
  if (tmp_nextUpStyle != map.end()) {
    fromRawValue(context, tmp_nextUpStyle->second, result.nextUpStyle);
  }
  auto tmp_styling = map.find("styling");
  if (tmp_styling != map.end()) {
    fromRawValue(context, tmp_styling->second, result.styling);
  }
  auto tmp_backgroundAudioEnabled = map.find("backgroundAudioEnabled");
  if (tmp_backgroundAudioEnabled != map.end()) {
    fromRawValue(context, tmp_backgroundAudioEnabled->second, result.backgroundAudioEnabled);
  }
  auto tmp_category = map.find("category");
  if (tmp_category != map.end()) {
    fromRawValue(context, tmp_category->second, result.category);
  }
  auto tmp_categoryOptions = map.find("categoryOptions");
  if (tmp_categoryOptions != map.end()) {
    fromRawValue(context, tmp_categoryOptions->second, result.categoryOptions);
  }
  auto tmp_mode = map.find("mode");
  if (tmp_mode != map.end()) {
    fromRawValue(context, tmp_mode->second, result.mode);
  }
  auto tmp_fullScreenOnLandscape = map.find("fullScreenOnLandscape");
  if (tmp_fullScreenOnLandscape != map.end()) {
    fromRawValue(context, tmp_fullScreenOnLandscape->second, result.fullScreenOnLandscape);
  }
  auto tmp_landscapeOnFullScreen = map.find("landscapeOnFullScreen");
  if (tmp_landscapeOnFullScreen != map.end()) {
    fromRawValue(context, tmp_landscapeOnFullScreen->second, result.landscapeOnFullScreen);
  }
  auto tmp_portraitOnExitFullScreen = map.find("portraitOnExitFullScreen");
  if (tmp_portraitOnExitFullScreen != map.end()) {
    fromRawValue(context, tmp_portraitOnExitFullScreen->second, result.portraitOnExitFullScreen);
  }
  auto tmp_exitFullScreenOnPortrait = map.find("exitFullScreenOnPortrait");
  if (tmp_exitFullScreenOnPortrait != map.end()) {
    fromRawValue(context, tmp_exitFullScreenOnPortrait->second, result.exitFullScreenOnPortrait);
  }
  auto tmp_playlist = map.find("playlist");
  if (tmp_playlist != map.end()) {
    fromRawValue(context, tmp_playlist->second, result.playlist);
  }
  auto tmp_stretching = map.find("stretching");
  if (tmp_stretching != map.end()) {
    fromRawValue(context, tmp_stretching->second, result.stretching);
  }
  auto tmp_related = map.find("related");
  if (tmp_related != map.end()) {
    fromRawValue(context, tmp_related->second, result.related);
  }
  auto tmp_preload = map.find("preload");
  if (tmp_preload != map.end()) {
    fromRawValue(context, tmp_preload->second, result.preload);
  }
  auto tmp_interfaceBehavior = map.find("interfaceBehavior");
  if (tmp_interfaceBehavior != map.end()) {
    fromRawValue(context, tmp_interfaceBehavior->second, result.interfaceBehavior);
  }
  auto tmp_interfaceFadeDelay = map.find("interfaceFadeDelay");
  if (tmp_interfaceFadeDelay != map.end()) {
    fromRawValue(context, tmp_interfaceFadeDelay->second, result.interfaceFadeDelay);
  }
  auto tmp_hideUIGroups = map.find("hideUIGroups");
  if (tmp_hideUIGroups != map.end()) {
    fromRawValue(context, tmp_hideUIGroups->second, result.hideUIGroups);
  }
  auto tmp_processSpcUrl = map.find("processSpcUrl");
  if (tmp_processSpcUrl != map.end()) {
    fromRawValue(context, tmp_processSpcUrl->second, result.processSpcUrl);
  }
  auto tmp_fairplayCertUrl = map.find("fairplayCertUrl");
  if (tmp_fairplayCertUrl != map.end()) {
    fromRawValue(context, tmp_fairplayCertUrl->second, result.fairplayCertUrl);
  }
  auto tmp_contentUUID = map.find("contentUUID");
  if (tmp_contentUUID != map.end()) {
    fromRawValue(context, tmp_contentUUID->second, result.contentUUID);
  }
  auto tmp_viewOnly = map.find("viewOnly");
  if (tmp_viewOnly != map.end()) {
    fromRawValue(context, tmp_viewOnly->second, result.viewOnly);
  }
  auto tmp_enableLockScreenControls = map.find("enableLockScreenControls");
  if (tmp_enableLockScreenControls != map.end()) {
    fromRawValue(context, tmp_enableLockScreenControls->second, result.enableLockScreenControls);
  }
  auto tmp_pipEnabled = map.find("pipEnabled");
  if (tmp_pipEnabled != map.end()) {
    fromRawValue(context, tmp_pipEnabled->second, result.pipEnabled);
  }
}

static inline std::string toString(const RNJWPlayerConfigStruct &value) {
  return "[Object RNJWPlayerConfigStruct]";
}
class RNJWPlayerProps final : public ViewProps {
 public:
  RNJWPlayerProps() = default;
  RNJWPlayerProps(const PropsParserContext& context, const RNJWPlayerProps &sourceProps, const RawProps &rawProps);

#pragma mark - Props

  RNJWPlayerConfigStruct config{};
  bool controls{false};
};

} // namespace react
} // namespace facebook
